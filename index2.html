<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Chess Game</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            flex-direction: column;
        }

        #game {
            display: flex;
            align-items: flex-start;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            width: 480px;
            height: 480px;
            border: 5px solid #333;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
            user-select: none;
            /* Prevent text selection */
        }

        .light {
            background-color: #f0d9b5;
        }

        .dark {
            background-color: #b58863;
        }

        .piece {
            /* Base style for pieces if needed */
        }

        .selected {
            background-color: #6495ED !important;
            /* Cornflower blue */
        }

        .possible-move {
            background-color: rgba(144, 238, 144, 0.7) !important;
            /* Light green overlay */
            border-radius: 50%;
        }

        .capture-move {
            background-color: rgba(255, 99, 71, 0.7) !important;
            /* Tomato overlay */
            border-radius: 50%;
        }

        .in-check {
            background-color: rgba(255, 0, 0, 0.5) !important;
            /* Red highlight for checked king */
        }

        #controls {
            margin-left: 20px;
            text-align: center;
        }

        #status {
            font-size: 1.2em;
            margin-bottom: 10px;
            min-height: 1.5em;
            font-weight: bold;
        }

        #move-history {
            height: 400px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 5px;
            margin-top: 10px;
            background-color: white;
            font-size: 0.9em;
            width: 150px;
        }

        button {
            padding: 10px 15px;
            font-size: 1em;
            cursor: pointer;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <h1>Simple Chess</h1>
    <div id="game">
        <div id="board"></div>
        <div id="controls">
            <div id="status">White's Turn</div>
            <button id="resetButton">New Game</button>
            <div id="move-history-container">
                <h4>Move History</h4>
                <div id="move-history"></div>
            </div>
        </div>
    </div>

    <script>
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const moveHistoryElement = document.getElementById('move-history');

        // Piece representation (Unicode)
        const pieces = {
            'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', // White
            'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚'  // Black
        };

        let boardState = []; // 8x8 array representing the board
        let currentPlayer = 'white'; // 'white' or 'black'
        let selectedSquare = null; // { row: r, col: c }
        let possibleMoves = []; // Array of possible move coordinates [{row, col}, ...]
        let whiteKingPos = { row: 7, col: 4 };
        let blackKingPos = { row: 0, col: 4 };
        let isGameOver = false;
        let moveLog = [];
        let moveCounter = 0;

        // --- Core Game Logic ---

        function initializeBoard() {
            boardState = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
            currentPlayer = 'white';
            selectedSquare = null;
            possibleMoves = [];
            whiteKingPos = { row: 7, col: 4 };
            blackKingPos = { row: 0, col: 4 };
            isGameOver = false;
            moveLog = [];
            moveCounter = 0;
            updateStatus("White's Turn");
            renderBoard();
            renderMoveHistory();
        }

        function renderBoard() {
            boardElement.innerHTML = ''; // Clear previous board
            let checkedKingPos = null;
            if (isKingInCheck(currentPlayer)) {
                checkedKingPos = (currentPlayer === 'white') ? whiteKingPos : blackKingPos;
            }


            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = r;
                    square.dataset.col = c;

                    const piece = boardState[r][c];
                    if (piece) {
                        square.textContent = pieces[piece];
                        square.classList.add('piece');
                    }

                    // Highlight selected square
                    if (selectedSquare && selectedSquare.row === r && selectedSquare.col === c) {
                        square.classList.add('selected');
                    }

                    // Highlight possible moves
                    const isPossible = possibleMoves.some(move => move.row === r && move.col === c);
                    if (isPossible) {
                        const targetPiece = boardState[r][c];
                        if (targetPiece) {
                            square.classList.add('capture-move'); // Highlight captures differently
                        } else {
                            square.classList.add('possible-move');
                        }
                    }

                    // Highlight checked king
                    if (checkedKingPos && checkedKingPos.row === r && checkedKingPos.col === c) {
                        square.classList.add('in-check');
                    }


                    square.addEventListener('click', () => handleSquareClick(r, c));
                    boardElement.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (isGameOver) return;
            if (currentPlayer === 'black') return; // Only allow human (white) clicks for now

            const clickedPiece = boardState[row][col];
            const isPossibleMove = possibleMoves.some(move => move.row === row && move.col === col);

            if (selectedSquare) {
                // If a square is already selected
                if (isPossibleMove) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    selectedSquare = null;
                    possibleMoves = [];
                    renderBoard(); // Re-render immediately after human move

                    // Check game state after human move
                    if (checkGameOver()) {
                        return;
                    }

                    // Trigger bot move after a short delay
                    switchTurn();
                    setTimeout(makeBotMove, 500); // 500ms delay for bot move
                } else {
                    // Clicked somewhere else, deselect or select new piece
                    selectedSquare = null;
                    possibleMoves = [];
                    // If clicked on own piece, select it
                    if (clickedPiece && isPieceOfCurrentPlayer(clickedPiece)) {
                        selectedSquare = { row, col };
                        possibleMoves = getLegalMoves(row, col);
                    }
                    renderBoard();
                }
            } else {
                // If no square is selected
                if (clickedPiece && isPieceOfCurrentPlayer(clickedPiece)) {
                    // Select the piece if it belongs to the current player
                    selectedSquare = { row, col };
                    possibleMoves = getLegalMoves(row, col);
                    renderBoard();
                }
            }
        }

        function getPieceColor(piece) {
            if (!piece) return null;
            return piece === piece.toUpperCase() ? 'white' : 'black';
        }

        function isPieceOfCurrentPlayer(piece) {
            if (!piece) return false;
            const pieceColor = getPieceColor(piece);
            return pieceColor === currentPlayer;
        }

        function switchTurn() {
            currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
            updateStatus(currentPlayer === 'white' ? "White's Turn" : "Black's Turn");
            // Add check status if applicable
            if (isKingInCheck(currentPlayer)) {
                updateStatus(statusElement.textContent + " (Check!)");
            }
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = boardState[fromRow][fromCol];
            const capturedPiece = boardState[toRow][toCol]; // Store potentially captured piece
            const moveNotation = getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece);

            boardState[toRow][toCol] = piece;
            boardState[fromRow][fromCol] = null;

            // Update king position if king moved
            if (piece === 'K') whiteKingPos = { row: toRow, col: toCol };
            if (piece === 'k') blackKingPos = { row: toRow, col: toCol };

            logMove(moveNotation);

            // No need to switch turn here, it's handled after the move completes
        }

        function logMove(notation) {
            if (currentPlayer === 'white') {
                moveCounter++;
                moveLog.push(`${moveCounter}. ${notation}`);
            } else {
                // Append black's move to the last log entry
                if (moveLog.length > 0) {
                    moveLog[moveLog.length - 1] += ` ${notation}`;
                } else {
                    // Should ideally not happen if white moves first
                    moveLog.push(`... ${notation}`);
                }
            }
            renderMoveHistory();
        }

        function renderMoveHistory() {
            moveHistoryElement.innerHTML = moveLog.join('<br>');
            // Scroll to bottom
            moveHistoryElement.scrollTop = moveHistoryElement.scrollHeight;
        }

        function getMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece) {
            const pieceType = piece.toUpperCase();
            let notation = '';

            if (pieceType !== 'P') {
                notation += pieceType; // Use piece letter (except for pawns)
            }

            // Basic coordinates (algebraic notation is more complex)
            // notation += String.fromCharCode(97 + fromCol) + (8 - fromRow); // From square
            if (capturedPiece) {
                if (pieceType === 'P') notation += String.fromCharCode(97 + fromCol); // Pawn capture needs file
                notation += 'x'; // Capture indicator
            } else {
                // notation += '-'; // Move indicator
            }
            notation += String.fromCharCode(97 + toCol) + (8 - toRow); // To square

            // Simplified check/checkmate symbols (more complex to calculate accurately here)
            // if (isKingInCheck(getOpponentColor(currentPlayer))) {
            //     // Need to check if *this specific move* causes checkmate/check
            // }

            return notation;
        }


        function updateStatus(message) {
            statusElement.textContent = message;
        }

        // --- Move Validation ---

        function getLegalMoves(row, col) {
            const piece = boardState[row][col];
            if (!piece) return [];

            let moves = [];
            const pieceType = piece.toUpperCase();

            switch (pieceType) {
                case 'P': moves = getPawnMoves(row, col, piece); break;
                case 'R': moves = getRookMoves(row, col, piece); break;
                case 'N': moves = getKnightMoves(row, col, piece); break;
                case 'B': moves = getBishopMoves(row, col, piece); break;
                case 'Q': moves = getQueenMoves(row, col, piece); break;
                case 'K': moves = getKingMoves(row, col, piece); break;
            }

            // Filter out moves that leave the king in check
            const legalMoves = moves.filter(move => {
                // Simulate the move
                const originalPiece = boardState[move.row][move.col];
                boardState[move.row][move.col] = piece;
                boardState[row][col] = null;
                const kingPos = (getPieceColor(piece) === 'white') ? whiteKingPos : blackKingPos;
                // Update king pos temporarily if king moved
                let originalKingPos = { ...kingPos };
                if (pieceType === 'K') {
                    if (getPieceColor(piece) === 'white') whiteKingPos = { row: move.row, col: move.col };
                    else blackKingPos = { row: move.row, col: move.col };
                }


                const isInCheckAfterMove = isKingInCheck(getPieceColor(piece));

                // Undo the move
                boardState[row][col] = piece;
                boardState[move.row][move.col] = originalPiece;
                if (pieceType === 'K') {
                    if (getPieceColor(piece) === 'white') whiteKingPos = originalKingPos;
                    else blackKingPos = originalKingPos;
                }


                return !isInCheckAfterMove;
            });


            return legalMoves;
        }

        function isValid(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function getOpponentColor(color) {
            return color === 'white' ? 'black' : 'white';
        }

        function getPawnMoves(row, col, piece) {
            const moves = [];
            const color = getPieceColor(piece);
            const direction = (color === 'white') ? -1 : 1;
            const startRow = (color === 'white') ? 6 : 1;

            // Forward 1
            const nextRow = row + direction;
            if (isValid(nextRow, col) && !boardState[nextRow][col]) {
                moves.push({ row: nextRow, col: col });
                // Forward 2 (from start)
                if (row === startRow) {
                    const twoRowsForward = row + 2 * direction;
                    if (isValid(twoRowsForward, col) && !boardState[twoRowsForward][col]) {
                        moves.push({ row: twoRowsForward, col: col });
                    }
                }
            }

            // Captures
            const captureCols = [col - 1, col + 1];
            for (const captureCol of captureCols) {
                if (isValid(nextRow, captureCol)) {
                    const targetPiece = boardState[nextRow][captureCol];
                    if (targetPiece && getPieceColor(targetPiece) !== color) {
                        moves.push({ row: nextRow, col: captureCol });
                    }
                    // TODO: En Passant would go here
                }
            }
            // TODO: Pawn Promotion would be checked/handled after move is made

            return moves;
        }

        function getRookMoves(row, col, piece) {
            return getSlidingMoves(row, col, piece, [[-1, 0], [1, 0], [0, -1], [0, 1]]);
        }

        function getBishopMoves(row, col, piece) {
            return getSlidingMoves(row, col, piece, [[-1, -1], [-1, 1], [1, -1], [1, 1]]);
        }

        function getQueenMoves(row, col, piece) {
            return getSlidingMoves(row, col, piece, [
                [-1, 0], [1, 0], [0, -1], [0, 1], // Rook directions
                [-1, -1], [-1, 1], [1, -1], [1, 1]  // Bishop directions
            ]);
        }

        function getSlidingMoves(row, col, piece, directions) {
            const moves = [];
            const color = getPieceColor(piece);

            for (const [dr, dc] of directions) {
                for (let i = 1; ; i++) {
                    const nextRow = row + i * dr;
                    const nextCol = col + i * dc;

                    if (!isValid(nextRow, nextCol)) break; // Off board

                    const targetPiece = boardState[nextRow][nextCol];
                    if (targetPiece) {
                        if (getPieceColor(targetPiece) !== color) {
                            moves.push({ row: nextRow, col: nextCol }); // Capture
                        }
                        break; // Blocked by own or enemy piece
                    } else {
                        moves.push({ row: nextRow, col: nextCol }); // Empty square
                    }
                }
            }
            return moves;
        }


        function getKnightMoves(row, col, piece) {
            const moves = [];
            const color = getPieceColor(piece);
            const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];

            for (const [dr, dc] of knightMoves) {
                const nextRow = row + dr;
                const nextCol = col + dc;

                if (isValid(nextRow, nextCol)) {
                    const targetPiece = boardState[nextRow][nextCol];
                    if (!targetPiece || getPieceColor(targetPiece) !== color) {
                        moves.push({ row: nextRow, col: nextCol });
                    }
                }
            }
            return moves;
        }

        function getKingMoves(row, col, piece) {
            const moves = [];
            const color = getPieceColor(piece);
            const kingMoves = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];

            for (const [dr, dc] of kingMoves) {
                const nextRow = row + dr;
                const nextCol = col + dc;

                if (isValid(nextRow, nextCol)) {
                    const targetPiece = boardState[nextRow][nextCol];
                    if (!targetPiece || getPieceColor(targetPiece) !== color) {
                        // Basic validation - more needed for check prevention
                        moves.push({ row: nextRow, col: nextCol });
                    }
                }
            }
            // TODO: Castling would go here - requires checking if king/rook moved, squares are clear, and not moving through check.

            return moves;
        }

        // --- Check and Checkmate ---

        function isKingInCheck(kingColor) {
            const kingPos = (kingColor === 'white') ? whiteKingPos : blackKingPos;
            const opponentColor = getOpponentColor(kingColor);

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardState[r][c];
                    if (piece && getPieceColor(piece) === opponentColor) {
                        // Get potential moves for this opponent piece *without* check validation
                        const potentialMoves = getPotentialMovesIgnoringCheck(r, c);
                        if (potentialMoves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                            return true; // Found a piece attacking the king
                        }
                    }
                }
            }
            return false;
        }

        // Helper function to get moves for check detection, ignoring the 'cannot move into check' rule
        function getPotentialMovesIgnoringCheck(row, col) {
            const piece = boardState[row][col];
            if (!piece) return [];
            const pieceType = piece.toUpperCase();
            switch (pieceType) {
                case 'P': return getPawnMoves(row, col, piece);
                case 'R': return getRookMoves(row, col, piece);
                case 'N': return getKnightMoves(row, col, piece);
                case 'B': return getBishopMoves(row, col, piece);
                case 'Q': return getQueenMoves(row, col, piece);
                case 'K': return getKingMoves(row, col, piece); // King attacking king handled by distance check essentially
                default: return [];
            }
        }

        function getAllLegalMoves(color) {
            const allMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardState[r][c];
                    if (piece && getPieceColor(piece) === color) {
                        const legalMoves = getLegalMoves(r, c); // This already includes check validation
                        if (legalMoves.length > 0) {
                            // Add origin info for the bot
                            legalMoves.forEach(move => allMoves.push({ fromRow: r, fromCol: c, toRow: move.row, toCol: move.col }));
                        }
                    }
                }
            }
            return allMoves;
        }

        function checkGameOver() {
            const legalMoves = getAllLegalMoves(currentPlayer);

            if (legalMoves.length === 0) {
                isGameOver = true;
                if (isKingInCheck(currentPlayer)) {
                    updateStatus(`Checkmate! ${getOpponentColor(currentPlayer)} wins!`);
                } else {
                    updateStatus("Stalemate! It's a draw!");
                }
                return true; // Game is over
            }
            return false; // Game continues
        }

        // --- Bot Logic ---

        function makeBotMove() {
            if (isGameOver || currentPlayer !== 'black') return;

            const allMoves = getAllLegalMoves('black');

            if (allMoves.length === 0) {
                // This should be caught by checkGameOver, but double-check
                checkGameOver();
                renderBoard(); // Render final state
                return;
            }

            // Simple Bot: Choose a random move
            const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];

            // Make the chosen move
            makeMove(randomMove.fromRow, randomMove.fromCol, randomMove.toRow, randomMove.toCol);

            // Check if bot move resulted in check or game over
            if (isKingInCheck('white')) {
                updateStatus("White's Turn (Check!)");
            } else {
                updateStatus("White's Turn");
            }

            if (checkGameOver()) { // Check if black's move ended the game
                renderBoard();
                return;
            }

            // Switch back to human player
            switchTurn(); // Switch turn AFTER bot move is done and board state is potentially updated by checkGameOver

            renderBoard(); // Re-render board after bot move and turn switch
        }


        // --- Event Listeners ---
        resetButton.addEventListener('click', initializeBoard);

        // --- Initial Game Setup ---
        initializeBoard();

    </script>
</body>

</html>